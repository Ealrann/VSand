#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1248
#define HEIGHT 704

#define CHUNK_WIDTH 39
#define CHUNK_HEIGHT 22

#define WORKGROUP_SIZE_X 32
#define WORKGROUP_SIZE_Y 32

#define MATERIAL_COUNT 32

precision lowp float;

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	uint rgb;
};

// Random number, change each frame.
layout (push_constant) uniform PushConstants {
	float random;
	int firstPass;
	int showSleepChunks;
} pushConstants;

layout(binding = 0) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

layout(binding = 1) readonly buffer SBoard
{
	int data[WIDTH][HEIGHT];
	int chunks[CHUNK_WIDTH][CHUNK_HEIGHT];
}board;

layout(rgba8, binding = 2) uniform image2D outImage;

const uint G_MASK = 255 << 8;
const uint B_MASK = 255;
const vec4 DEBUG_COLOR = vec4(1.0, 0.5, 0.5, 0.0);

void main()
{
	if (gl_GlobalInvocationID.y >= HEIGHT)
		return;

	if((board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] & 4) == 0)
	{
		if(pushConstants.showSleepChunks == 1)
		{
			uint index = board.data[gl_GlobalInvocationID.x][gl_GlobalInvocationID.y];
			Entry material = configuration.materials[index];
			vec4 color = unpackUnorm4x8(material.rgb) / 4;
			color.r = 0.0;
			imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), DEBUG_COLOR + color);
		}
		return;
	}

	uint index = board.data[gl_GlobalInvocationID.x][gl_GlobalInvocationID.y];
	Entry material = configuration.materials[index];
	vec4 color = unpackUnorm4x8(material.rgb);
	imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), color);
}
