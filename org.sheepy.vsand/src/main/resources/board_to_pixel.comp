#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1248
#define HEIGHT 704

#define CHUNK_WIDTH 39
#define CHUNK_HEIGHT 22

#define WORKGROUP_SIZE_X 32
#define WORKGROUP_SIZE_Y 32

#define MATERIAL_COUNT 32

precision lowp float;

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	int padding;
	vec4 color;
};

// Random number, change each frame.
layout (push_constant) uniform PushConstants {
	float random;
	int forceClear;
	int showSleepChunks;
	int drawRadius;
	ivec2 mousePos;
	int drawMaterialId;
} pushConstants;

layout(binding = 0) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

layout(binding = 1) buffer SBoard
{
	int data[WIDTH][HEIGHT];
	int chunks[CHUNK_WIDTH][CHUNK_HEIGHT];
}board;

layout(rgba8, binding = 2) uniform image2D outImage;

const uint G_MASK = 255 << 8;
const uint B_MASK = 255;
const vec4 DEBUG_COLOR = vec4(1.0, 0.5, 0.5, 0.0);


bool testCircle(int x, int y, int circleX, int circleY, int radius);

void main()
{
	if (gl_GlobalInvocationID.y >= HEIGHT)
		return;
	
	int x = int(gl_GlobalInvocationID.x);
	int y = int(gl_GlobalInvocationID.y);

	bool colorTweak = false;
	vec4 addColor = vec4(0, 0, 0, 0);
	if(testCircle(x, y, pushConstants.mousePos.x, pushConstants.mousePos.y, pushConstants.drawRadius))
	{
		Entry material = configuration.materials[pushConstants.drawMaterialId];
		addColor+= material.color;
		atomicOr(board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y], 12);
		colorTweak = true;
	}

	int chunkState = board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y];
	if(gl_LocalInvocationIndex == 0)
	{
		atomicCompSwap(board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y], 4, 8);
		atomicCompSwap(board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y], 6, 10);
	}

	if(pushConstants.forceClear == 0 && colorTweak == false && (chunkState & 12) == 0)
	{
		if(pushConstants.showSleepChunks == 1)
		{
			addColor += vec4(1, 0.5, 0.5, 0);
			colorTweak = true;
		}
		else
		{
			return;
		}
	}

	uint index = board.data[x][y];
	Entry material = configuration.materials[index];
	
	if(colorTweak)
		imageStore(outImage, ivec2(x, y), ((material.color * 3) + addColor) / 4);
	else
		imageStore(outImage, ivec2(x, y), material.color);
}

bool testCircle(int x, int y, int circleX, int circleY, int radius)
{
	if(x >= pushConstants.mousePos.x - pushConstants.drawRadius
		&& y >= pushConstants.mousePos.y - pushConstants.drawRadius
		&& x <= pushConstants.mousePos.x + pushConstants.drawRadius
		&& y <= pushConstants.mousePos.y + pushConstants.drawRadius)
	{
		int distX = (circleX - x) * (circleX - x);
		int distY = (circleY - y) * (circleY - y);
		return (distX + distY) <= (radius * radius);
	}
	return false;
}
