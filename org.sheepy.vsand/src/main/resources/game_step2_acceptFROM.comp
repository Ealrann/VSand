#version 450

#define WIDTH 1248
#define HEIGHT 704

#define CHUNK_WIDTH 39
#define CHUNK_HEIGHT 22

#define WORKGROUP_SIZE_X 32
#define WORKGROUP_SIZE_Y 32

#define UP    0
#define DOWN  1
#define RIGHT 2
#define LEFT  3

#define TO_UP    1 << 0
#define TO_DOWN  1 << 1
#define TO_RIGHT 1 << 2
#define TO_LEFT  1 << 3

#define RANDOM_1_LOC  8
#define RANDOM_2_LOC  10
#define RANDOM_3_LOC  12
#define RANDOM_4_LOC  14

#define MATERIAL_COUNT 32

#define TARGET_VALUE_POSITION 16

const uint TARGET_VALUE_MASK = 255 << TARGET_VALUE_POSITION;

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	uint rgb;
};

// Random number, change each frame.
layout (push_constant) uniform PushConstants {
	float random;
	int firstPass;
	int showSleepChunks;
} pushConstants;

// The definition of materials.
layout(binding = 0) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

// The game board, with all the values.
layout(binding = 1) buffer SBoard
{
	int data[WIDTH][HEIGHT];
	int chunks[CHUNK_WIDTH][CHUNK_HEIGHT];
}board;

// DecisionBoard store necessary informations around movement.
// Each 32 bit value (one per cell) stores:
// 8 bits for the initial value
// 8 bits for the swapped value
// 8 bits with a random value.
//		This value is divided in 4 value of 2 bit, and represent
// 		a random array containing all the unique values : 0, 1, 2 and 3.
//		Used to have a favourite neighboors per cells.
// 3 unused bits.
// 1 bit, true if the cell is swapped.
// 4 bits for the direction we intend to swap.
layout(binding = 2) buffer SDecision
{
	uint data[WIDTH][HEIGHT];
}decision;

/**
 * For the pixels that have no preferences, if a neighbor want to come here, we accept the move.
 */
void main()
{
	if (gl_GlobalInvocationID.y >= HEIGHT)
		return;

	// If disabled chunk and not edge cell, we return
	if((board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] & 1) == 0
			&& (gl_LocalInvocationID.x != 0 && gl_LocalInvocationID.x != 31)
			&& (gl_LocalInvocationID.y != 0 && gl_LocalInvocationID.y != 31)
			&& gl_GlobalInvocationID.y != HEIGHT - 1)
	{
		return;
	}

	int x = int(gl_GlobalInvocationID.x);
	int y = int(gl_GlobalInvocationID.y);
	int value = board.data[x][y];

	bool validTarget;
	int targetValue;
	int targetDensity;
	int density;
	int rLocation;
	int invertDir;
	int targetX;
	int targetY;
	uint decisionValue;
	uint maskDir;
	uint iDir;

	if (configuration.materials[value].isStatic == 0)
	{
		density = configuration.materials[value].density;
		rLocation = RANDOM_1_LOC;

		decisionValue = decision.data[x][y];

		for (int i = 0; i < 4; i++)
		{
			iDir = (decisionValue & (3 << rLocation)) >> rLocation;
			// iDir should be between 0 and 3 (included) here

			// The down is impossible here:
			// We cannot be the target of a heavier down object.
			if (iDir != DOWN)
			{
				// resolve the direction
				invertDir = -1;
				targetX = x;
				targetY = y;
				switch (iDir)
				{
				case RIGHT:
					targetX += 1;
					invertDir = TO_LEFT;
					break;
				case LEFT:
					targetX -= 1;
					invertDir = TO_RIGHT;
					break;
				case UP:
					targetY -= 1;
					invertDir = TO_DOWN;
					break;
				default:
					break;
				}

				if (invertDir != -1)
				{
					validTarget = (targetX >= 0) && (targetX < WIDTH)
							&& (targetY >= 0) && (targetY < HEIGHT);
					targetValue =
							validTarget ? board.data[targetX][targetY] : 0;
					targetDensity =
							configuration.materials[targetValue].density;

					if (targetDensity > density
							&& (!validTarget
									|| ((decision.data[targetX][targetY]
											& invertDir) != 0)))
					{
						// convert iDir to a mask
						maskDir = 1 << iDir;

						// Erase the target value to put the new one
						decision.data[x][y] |= TARGET_VALUE_MASK;
						decision.data[x][y] ^= TARGET_VALUE_MASK;

						decision.data[x][y] = ((decision.data[x][y] >> 8) << 8)
								| maskDir
								| (targetValue << TARGET_VALUE_POSITION);

						board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] |= 1;

						i = 4; //break;
					}
				}
			}

			rLocation += 2;
		}
	}
}
