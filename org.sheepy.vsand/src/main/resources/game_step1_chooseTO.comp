#version 450

#define WIDTH 1248
#define HEIGHT 704

#define CHUNK_WIDTH 39
#define CHUNK_HEIGHT 22

#define WORKGROUP_SIZE_X 32
#define WORKGROUP_SIZE_Y 32

#define UP    0
#define DOWN  1
#define RIGHT 2
#define LEFT  3

#define TO_UP    1 << 0
#define TO_DOWN  1 << 1
#define TO_RIGHT 1 << 2
#define TO_LEFT  1 << 3

#define RANDOM_1_LOC  8
#define RANDOM_2_LOC  10
#define RANDOM_3_LOC  12
#define RANDOM_4_LOC  14

#define MATERIAL_COUNT 32

#define TARGET_VALUE_POSITION 16
#define INITIAL_VALUE_POSITION 24

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	uint rgb;
};

// Random number, change each frame.
layout (push_constant) uniform PushConstants {
	float random;
	int firstPass;
} pushConstants;

// The definition of materials.
layout(binding = 0) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

// The game board, with all the values.
layout(binding = 1) buffer SBoard
{
	int data[WIDTH][HEIGHT];
	int chunks[CHUNK_WIDTH][CHUNK_HEIGHT];
}board;

// DecisionBoard store necessary informations around movement.
// Each 32 bit value (one per cell) stores:
// 8 bits for the initial value
// 8 bits for the swapped value
// 8 bits with a random value.
//		This value is divided in 4 value of 2 bit, and represent
// 		a random array containing all the unique values : 0, 1, 2 and 3.
//		Used to have a favourite neighboors per cells.
// 3 unused bits.
// 1 bit, true if the cell is swapped.
// 4 bits for the direction we intend to swap.
layout(binding = 2) buffer SDecision
{
	uint data[WIDTH][HEIGHT];
}decision;

//int findLessCrowdedSide(int x, int y, int srcDensity, int runoff);
int checkFree(int x, int y, int runoff, int dir, int srcDensity);
float rand(vec2 co);
float gold_noise(in ivec2 coordinate, in float seed);

/**
 * Here, we will choose one favourite destination.
 */
void main()
{
	if (gl_GlobalInvocationID.y >= HEIGHT)
		return;

	int x = int(gl_GlobalInvocationID.x);
	int y = int(gl_GlobalInvocationID.y);

	int currentValue = board.data[x][y];
	// Erase Tag,
	// Erase previous value
	// and Store the current value to the decision buffer.
	decision.data[x][y] = (((decision.data[x][y] >> 8) << 24) >> 16)
			| (currentValue << INITIAL_VALUE_POSITION);


	// If disabled chunk and not edge cell, we return
	if((board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] & 7) == 0
		&& (gl_LocalInvocationID.x != 0 && gl_LocalInvocationID.x != 31)
		&& (gl_LocalInvocationID.y != 0 && gl_LocalInvocationID.y != 31)
		&& gl_GlobalInvocationID.y != HEIGHT - 1)
	{
		return;
	}

	if (configuration.materials[currentValue].isStatic == 0)
	{
		int density = configuration.materials[currentValue].density;

		int valueDown = y < (HEIGHT - 1) ? board.data[x][y + 1] : 0;
		// Make a list of available directions

		if (configuration.materials[valueDown].isStatic == 0
				&& density > configuration.materials[valueDown].density
				&& gold_noise(ivec2(x, y), pushConstants.random) < 0.92)
		{
			decision.data[x][y] |= TO_DOWN | (valueDown << TARGET_VALUE_POSITION);
			board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] |= 1;
		}
		else
		{
			// If not fallingdown, we check the right/left move
			int valueLeft = x > 0 ? board.data[x - 1][y] : 0;
			int valueRight = x < (WIDTH - 1) ? board.data[x + 1][y] : 0;

			int runoff = configuration.materials[currentValue].runoff;
			int distLeft = runoff;
			int distRight = runoff;

			if (configuration.materials[valueLeft].density < density)
			{
				distLeft = checkFree(x - 1, y + 1, runoff, -1, density);
			}
			if (configuration.materials[valueRight].density < density)
			{
				distRight = checkFree(x + 1, y + 1, runoff, 1, density);
			}

			bool right = distRight < runoff;
			bool left = distLeft < runoff;
			int targetValue = 0;

			if (right || left)
			{
				uint tag = 0;
				if (right && left)
				{
					if (distRight < distLeft)
					{
						tag = TO_RIGHT;
						targetValue = valueRight;
					}
					else if (distRight > distLeft)
					{
						tag = TO_LEFT;
						targetValue = valueLeft;
					}
					else // if (distLeft == distRight)
					{
						/*int lessCrowdedSide = 0;
						if(mod(pushConstants.random, 3) != 0)
						{
							findLessCrowdedSide(x, y, density, 3);
						}

						if (lessCrowdedSide == 1)
						{
							tag = TO_RIGHT;
							targetValue = valueRight;
						}
						else if (lessCrowdedSide == -1)
						{
							tag = TO_LEFT;
							targetValue = valueLeft;
						}
						else*/
						// We prefer left side. Right is naturally favourized due to
						// the course of the shader: left to right.
						if (gold_noise(ivec2(x, y), pushConstants.random) < 0.95)
						{
							tag = TO_RIGHT;
							targetValue = valueRight;
						}
						else
						{
							tag = TO_LEFT;
							targetValue = valueLeft;
						}
					}
				}
				else
				{
					if (right)
					{
						tag = TO_RIGHT;
						targetValue = valueRight;
					}
					else if (left)
					{
						tag = TO_LEFT;
						targetValue = valueLeft;
					}
				}
				decision.data[x][y] |= tag | (targetValue << TARGET_VALUE_POSITION);
				board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] |= 1;
			}
		}
	}
}

/*// return -1 for left, 0 for nothing, 1 for right
int findLessCrowdedSide(int x, int y, int srcDensity, int runoff)
{
	int res = 0;

	for (int i = 1; i <= runoff; i++)
	{
		if (x + i >= WIDTH)
		{
			res = 1;
			break;
		}
		if (i > x)
		{
			res = -1;
			break;
		}

		int valueR = board.data[x + i][y];
		int valueL = board.data[x - i][y];
		if(configuration.materials[valueL].density >= srcDensity)
		{
			// left crowded, we return right
			res = 1;
			break;
		}
		if(configuration.materials[valueR].density >= srcDensity)
		{
			// right crowded, we return left
			res = -1;
			break;
		}
	}

	return res;
}*/

int checkFree(int x, int y, int runoff, int dir, int srcDensity)
{
	int course = 0;
	if (y >= 0 || y < HEIGHT)
	{
		while (runoff != 0)
		{
			if (x >= 0 && x < WIDTH)
			{
				int value = board.data[x][y];
				if (configuration.materials[value].isStatic == 0
						&& configuration.materials[value].density < srcDensity)
				{
					break;
				}
			}
			else
			{
				break;
			}
			x += dir;
			runoff--;
			course++;
		}
	}

	return course;
}

const float PHI = 1.61803398874989484820459 * 00000.1; // Golden Ratio
const float PI  = 3.14159265358979323846264 * 00000.1; // PI
const float SQ2 = 1.41421356237309504880169 * 10000.0; // Square Root of Two

float gold_noise(in ivec2 coordinate, in float seed)
{
    return fract(tan(distance(coordinate*(seed+PHI), vec2(PHI, PI)))*SQ2);
}

float rand(vec2 co)
{
	float a = 12.9898;
	float b = 78.233;
	float c = 43758.5453;
	float dt = dot(co.xy, vec2(a, b));
	float sn = mod(dt, 3.14);
	return fract(sin(sn) * c);
}
