#version 450

#define WORKGROUP_SIZE 64

#include "rand_utils.glsl"
#include "material.glsl"
#include "crop.glsl"
#include "board.glsl"

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const ivec2 BOARD_SIZE = ivec2(WIDTH, HEIGHT);


void loadBoard(const bool vertical);
void computeVertical();
void saveBoard(const bool vertical);

ivec2 globalOffset = ivec2(pushConstants.globalXOffset, pushConstants.globalYOffset);
ivec2 workgroupLoc = ivec2(gl_WorkGroupID.xy * WORKGROUP_SIZE) + globalOffset;

void main()
{
    //    computeHorizontal();
    //
    //    barrier();

    int x = workgroupLoc.x + int(gl_LocalInvocationID.x);
    if(x >= 0 && x < WIDTH)
    {
        loadBoard(true);
        computeVertical();
        saveBoard(true);
    }
}

void computeVertical()
{
    const uint x = gl_LocalInvocationID.x;
    int upIndex = -1;
    int middleIndex = cropQueue.firstIndex;
    int downIndex = cropQueue.queue[middleIndex].nextCrop;
    bool pushedDown = false;
    while(downIndex != -1)
    {
        if(cropQueue.queue[middleIndex].isStatic == false && cropQueue.queue[downIndex].isStatic == false)
        {
            const bool middleLiquidOrGaz = cropQueue.queue[middleIndex].isLiquid || cropQueue.queue[middleIndex].isGaz;
            const bool downLiquidOrGaz = cropQueue.queue[downIndex].isLiquid || cropQueue.queue[downIndex].isGaz;
            const bool liquidOrGaz = middleLiquidOrGaz && downLiquidOrGaz;

            if(pushedDown == false
                && liquidOrGaz
                && getMaterialId(middleIndex) == getMaterialId(downIndex))
            {
                if (upIndex != -1 && (cropQueue.queue[upIndex].isLiquid || cropQueue.queue[upIndex].isGaz))
                {
                    // Push down from up and transfer pressure down
                    growCropBottom(upIndex);
                    const float pressureToMoveDown = removeCropBottom(middleIndex);
                    cropQueue.queue[downIndex].pressure += pressureToMoveDown;
                    middleIndex = cropQueue.queue[downIndex].previousCrop;
                    pushedDown = true;
                }
                else
                {
                    // transfer pressure down
                    const float middleLastPressure = lastEffectivePressure(middleIndex);
                    cropQueue.queue[middleIndex].pressure -= middleLastPressure;
                    cropQueue.queue[downIndex].pressure += middleLastPressure;
                }
            }
            else if(pushedDown == false && getDensity(middleIndex) > getDensity(downIndex))
            {
                // Heavier material above
                if (downLiquidOrGaz
                        && upIndex != -1
                        && (cropQueue.queue[upIndex].isLiquid || cropQueue.queue[upIndex].isGaz)
                        && cropQueue.queue[downIndex].size > 1
                        && cropQueue.queue[downIndex].pressure < (2 * cropQueue.queue[downIndex].size))
//                        && lastPressure(upIndex, 1) >= 0.)
                {
                    // PUSH DOWN
                    growCropBottom(upIndex);
                    shrinkCropTop(downIndex);
                    pushedDown = true;
                }
                else
                {
                    // SWAP
                    const uint downSize = cropQueue.queue[downIndex].size;
                    const uint middleSize = cropQueue.queue[middleIndex].size;

                    if(downSize == 1 && middleSize == 1)
                    {
                        swapCropWithNext(middleIndex);
                        downIndex = cropQueue.queue[middleIndex].nextCrop;
                    }
                    else if (downSize == 1)
                    {
                        const int newMiddleAddress = splitCropBottom(middleIndex);
                        if(newMiddleAddress != -1)
                        {
                            swapCropWithNext(newMiddleAddress);
                            middleIndex = newMiddleAddress;
                            downIndex = cropQueue.queue[newMiddleAddress].nextCrop;
                        }
                    }
                    else if (middleSize == 1)
                    {
                        const int splitDownAddress = splitCropTop(downIndex);
                        if(splitDownAddress != -1) swapCropWithNext(middleIndex);
                    }
                    else if(cropQueue.size < CROP_QUEUE_SIZE - 2)
                    {
                        middleIndex = splitCropBottom(middleIndex);
                        splitCropTop(downIndex);
                        swapCropWithNext(uint(middleIndex));
                    }
//                  pushedDown = true;
                }
            }
            // PRESSURE
            else if (liquidOrGaz)// && cropQueue.queue[middleIndex].falling == false
                                 // && cropQueue.queue[downIndex].falling == false)
            {
                const bool downLiquid = cropQueue.queue[downIndex].isLiquid;
                const float downFirstPressure = firstEffectivePressure(downIndex);
                const float middleLastPressure = lastEffectivePressure(middleIndex);
                const float pressureDiff = downFirstPressure - middleLastPressure + PRESSURE_DELTA;
                const bool downOverpressure = downLiquid ? downFirstPressure > cropQueue.queue[downIndex].firstTheoreticalPressure : pressureDiff > PRESSURE_DELTA;
                const bool downUnderpressure = downLiquid ? downFirstPressure <= 0. : pressureDiff < -PRESSURE_DELTA;

                if (downOverpressure && cropQueue.queue[middleIndex].size > 1)
                {
                    pushCropUp(downIndex);
                }
                else if (downUnderpressure && pushedDown == false && cropQueue.queue[downIndex].size > 1)
                {
                    pushCropDown(middleIndex);
                }

                pushedDown = false;
            }
            else
            {
                pushedDown = false;
            }
        }

        upIndex = middleIndex;
        middleIndex = downIndex;
        downIndex = cropQueue.queue[middleIndex].nextCrop;
    }
}

void loadBoard(const bool vertical)
{
    const ivec2 directionOffset = vertical ? ivec2(gl_LocalInvocationID.x, 0) : ivec2(0, gl_LocalInvocationID.x);
    const ivec2 globalLocation = ivec2(workgroupLoc.xy) + directionOffset;
    const uvec2 startLocation = uvec2(clamp(globalLocation, ivec2(0, 0), BOARD_SIZE));
    const uvec2 endLocation = uvec2(min(globalLocation + WORKGROUP_SIZE, BOARD_SIZE));
    const uint size = vertical ? endLocation.y - startLocation.y : endLocation.x - startLocation.x;

    initQueue();
    loadCrops(startLocation, size, vertical);
}

void saveBoard(const bool vertical)
{
    const ivec2 directionOffset = vertical ? ivec2(gl_LocalInvocationID.x, 0) : ivec2(0, gl_LocalInvocationID.x);
    const ivec2 globalLocation = ivec2(workgroupLoc.xy) + directionOffset;
    const uvec2 startLocation = uvec2(clamp(globalLocation, ivec2(0, 0), BOARD_SIZE));
    const uvec2 endLocation = uvec2(min(globalLocation + WORKGROUP_SIZE, BOARD_SIZE));
    const uint size = vertical ? endLocation.y - startLocation.y : endLocation.x - startLocation.x;

    saveCrops(startLocation, size, vertical);
}
