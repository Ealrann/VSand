#version 450

#define WORKGROUP_SIZE 64

#include "util/rand_utils.glsl"
#include "util/material.glsl"
#include "util/crop.glsl"
#include "util/board.glsl"

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const ivec2 BOARD_SIZE = ivec2(WIDTH, HEIGHT);


void loadBoard(const bool vertical);
void computeVertical();
void computeHorizontal();
void saveBoard(const bool vertical);

ivec2 globalOffset = ivec2(pushConstants.globalXOffset, pushConstants.globalYOffset);
ivec2 workgroupLoc = ivec2(gl_WorkGroupID.xy * WORKGROUP_SIZE) + globalOffset;

shared bool toto;

void main()
{
    int y = workgroupLoc.y + int(gl_LocalInvocationID.x);
    if(y >= 0 && y < HEIGHT)
    {
        loadBoard(false);
        computeHorizontal();
        saveBoard(false);
    }

    barrier();

    int x = workgroupLoc.x + int(gl_LocalInvocationID.x);
    if(x >= 0 && x < WIDTH)
    {
        loadBoard(true);
        computeVertical();
        saveBoard(true);
    }
}

void computeHorizontal()
{
    int leftIndex = cropQueue.firstIndex;
    int rightIndex = cropQueue.queue[leftIndex].nextCrop;
    bool pushed = false;
    while(rightIndex != -1)
    {
        bool liquidOrGaz = (cropQueue.queue[leftIndex].isLiquid || cropQueue.queue[leftIndex].isGaz)
                            && (cropQueue.queue[rightIndex].isLiquid || cropQueue.queue[rightIndex].isGaz);
        if(liquidOrGaz && cropQueue.queue[leftIndex].falling == false && cropQueue.queue[rightIndex].falling == false)
        {
            const uint leftDensity = getDensity(leftIndex);
            const uint rightDensity = getDensity(rightIndex);
            const float leftPressure = cropQueue.queue[leftIndex].pressure;
            const float rightPressure = cropQueue.queue[rightIndex].pressure;
            const uint leftSize = cropQueue.queue[leftIndex].size;
            const uint rightSize = cropQueue.queue[rightIndex].size;

            if(leftPressure < 0.005)
            {
                if(leftSize > 1)
                {
                    cropQueue.queue[leftIndex].size--;
                }
                else
                {
                    removeCrop(leftIndex);
                    leftIndex = cropQueue.queue[rightIndex].previousCrop;
                }
                cropQueue.queue[rightIndex].size++;
            }
            else if (rightPressure < 0.005)
            {
                if(rightSize > 1)
                {
                    cropQueue.queue[rightIndex].size--;
                }
                else
                {
                    removeCrop(rightIndex);
                    rightIndex = cropQueue.queue[leftIndex].nextCrop;
                }
                cropQueue.queue[leftIndex].size++;
            }
            else if (rightDensity > leftDensity && leftSize > 1)
            {
                // Right to Left
                const float updatedRightPressure = rightPressure / (rightSize + 1);
                const float updatedLeftPressure = leftPressure / (leftSize - 1);
                if(updatedRightPressure > 0.05) // && updatedLeftPressure < 2.
                {
                    cropQueue.queue[leftIndex].size--;
                    cropQueue.queue[rightIndex].size++;
                    pushed = true;
                }
            }
            else if (leftDensity > rightDensity && rightSize > 1)
            {
                // Left to Right
                const float updatedRightPressure = rightPressure / (rightSize - 1);
                const float updatedLeftPressure = leftPressure / (leftSize + 1);
                if(updatedLeftPressure > 0.05) // && updatedRightPressure < 2.
                {
                    cropQueue.queue[leftIndex].size++;
                    cropQueue.queue[rightIndex].size--;
                    pushed = true;
                }
            }
            else
            {
                pushed = false;
            }
        }

        leftIndex = rightIndex;
        rightIndex = cropQueue.queue[rightIndex].nextCrop;
    }
}

void computeVertical()
{
    int upIndex = -1;
    int middleIndex = cropQueue.firstIndex;
    int downIndex = cropQueue.queue[middleIndex].nextCrop;
    bool pushedDown = false;
    while(downIndex != -1)
    {
        if(cropQueue.queue[middleIndex].isStatic == false && cropQueue.queue[downIndex].isStatic == false)
        {
            const bool middleLiquidOrGaz = cropQueue.queue[middleIndex].isLiquid || cropQueue.queue[middleIndex].isGaz;
            const bool downLiquidOrGaz = cropQueue.queue[downIndex].isLiquid || cropQueue.queue[downIndex].isGaz;
            const bool liquidOrGaz = middleLiquidOrGaz && downLiquidOrGaz;

            if(pushedDown == false
                && liquidOrGaz
                && getMaterialId(middleIndex) == getMaterialId(downIndex))
            {
                if (upIndex != -1 && (cropQueue.queue[upIndex].isLiquid || cropQueue.queue[upIndex].isGaz))
                {
                    // Push down from up and transfer pressure down
                    growCropBottom(upIndex);
                    const float pressureToMoveDown = removeCropBottom(middleIndex);
                    cropQueue.queue[downIndex].pressure += pressureToMoveDown;
                    middleIndex = cropQueue.queue[downIndex].previousCrop;
                    pushedDown = true;
                }
                else
                {
                    // transfer pressure down
                    const float middleLastPressure = lastIdealPressure(middleIndex);
                    cropQueue.queue[middleIndex].pressure -= middleLastPressure;
                    cropQueue.queue[downIndex].pressure += middleLastPressure;
                }
            }
            else if(getDensity(middleIndex) > getDensity(downIndex))
            {
                // Heavier material above
                if (downLiquidOrGaz
                        && pushedDown == false
                        && upIndex != -1
                        && (cropQueue.queue[upIndex].isLiquid || cropQueue.queue[upIndex].isGaz)
                        && cropQueue.queue[downIndex].size > 1
                        && cropQueue.queue[downIndex].pressure < (1.5 * cropQueue.queue[downIndex].size))
//                        && lastPressure(upIndex, 1) >= 0.)
                {
                    // PUSH DOWN
                    growCropBottom(upIndex);
                    shrinkCropTop(downIndex);
                    pushedDown = true;
                }
                else
                {
                    // SWAP
                    const uint downSize = cropQueue.queue[downIndex].size;
                    const uint middleSize = cropQueue.queue[middleIndex].size;

                    if(downSize == 1 && middleSize == 1)
                    {
                        swapCropWithNext(middleIndex);
                        downIndex = cropQueue.queue[middleIndex].nextCrop;
                    }
                    else if (downSize == 1)
                    {
                        const int newMiddleAddress = splitCropBottom(middleIndex);
                        if(newMiddleAddress != -1)
                        {
                            swapCropWithNext(newMiddleAddress);
                            middleIndex = newMiddleAddress;
                            downIndex = cropQueue.queue[newMiddleAddress].nextCrop;
                        }
                    }
                    else if (middleSize == 1)
                    {
                        const int splitDownAddress = splitCropTop(downIndex);
                        if(splitDownAddress != -1) swapCropWithNext(middleIndex);
                    }
                    else if(cropQueue.size < CROP_QUEUE_SIZE - 2)
                    {
                        middleIndex = splitCropBottom(middleIndex);
                        splitCropTop(downIndex);
                        swapCropWithNext(uint(middleIndex));
                    }
                    pushedDown = true;
                }
            }
            // PRESSURE
            else if (liquidOrGaz)// && cropQueue.queue[middleIndex].falling == false
                                 // && cropQueue.queue[downIndex].falling == false)
            {
//                const bool downLiquid = false; //cropQueue.queue[downIndex].isLiquid;
//                const float downFirstPressure = firstEffectivePressure(downIndex);
                const float downFirstIdealPressure = firstIdealPressure(downIndex);
                const float middleLastPressure = lastIdealPressure(middleIndex);
                const int middleDensity = getDensity(middleIndex);
                const float pressureDelta = PRESSURE_DELTA * (middleDensity + 3);
                const float middlePressure = middleLastPressure + pressureDelta;
                const float pressureDiff = downFirstIdealPressure - middlePressure;
//                const bool downOverpressure = downLiquid ? downFirstPressure > cropQueue.queue[downIndex].firstTheoreticalPressure : pressureDiff > pressureDelta;
//                const bool downUnderpressure = downLiquid ? downFirstPressure <= 0. : pressureDiff < -pressureDelta;
                const bool downOverpressure = pressureDiff > 0.;
                const bool downUnderpressure = pressureDiff < 0.;

                if (downOverpressure && cropQueue.queue[middleIndex].size > 1)
                {
                    const float downPushedPressure = firstIdealPressure(downIndex, 1);
                    const float middlePushedPressure = lastIdealPressure(middleIndex, -1) + pressureDelta;
                    if((downPushedPressure - middlePushedPressure) >= 0.)
                    {
                        pushCropUp(downIndex);
                        pushedDown = false;
                    }
                }
                else if (downUnderpressure && pushedDown == false && cropQueue.queue[downIndex].size > 1)
                {
                    const float downPushedPressure = firstIdealPressure(downIndex, -1);
                    const float middlePushedPressure = lastIdealPressure(middleIndex, 1) + pressureDelta;
                    if((downPushedPressure - middlePushedPressure) <= 0.)
                    {
                        pushCropDown(middleIndex);
                        pushedDown = true;
                    }
                }
            }
            else
            {
                pushedDown = false;
            }
        }

        upIndex = middleIndex;
        middleIndex = downIndex;
        downIndex = cropQueue.queue[middleIndex].nextCrop;
    }
}

void loadBoard(const bool vertical)
{
    const ivec2 directionOffset = vertical ? ivec2(gl_LocalInvocationID.x, 0) : ivec2(0, gl_LocalInvocationID.x);
    const ivec2 globalLocation = ivec2(workgroupLoc.xy) + directionOffset;
    const uvec2 startLocation = uvec2(clamp(globalLocation, ivec2(0, 0), BOARD_SIZE));
    const uvec2 endLocation = uvec2(min(globalLocation + WORKGROUP_SIZE, BOARD_SIZE));
    const uint size = vertical ? endLocation.y - startLocation.y : endLocation.x - startLocation.x;

    initQueue();
    loadCrops(startLocation, size, vertical);
}

void saveBoard(const bool vertical)
{
    const ivec2 directionOffset = vertical ? ivec2(gl_LocalInvocationID.x, 0) : ivec2(0, gl_LocalInvocationID.x);
    const ivec2 globalLocation = ivec2(workgroupLoc.xy) + directionOffset;
    const uvec2 startLocation = uvec2(clamp(globalLocation, ivec2(0, 0), BOARD_SIZE));
    const uvec2 endLocation = uvec2(min(globalLocation + WORKGROUP_SIZE, BOARD_SIZE));
    const uint size = vertical ? endLocation.y - startLocation.y : endLocation.x - startLocation.x;

    saveCrops(startLocation, size, vertical);
}
