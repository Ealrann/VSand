#version 450

#define WORKGROUP_SIZE 32

#include "util/rand_utils.glsl"
#include "util/material.glsl"
#include "util/crop.glsl"
#include "util/board.glsl"

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

const ivec2 BOARD_SIZE = ivec2(WIDTH, HEIGHT);


ivec2 globalOffset = ivec2(pushConstants.globalXOffset, pushConstants.globalYOffset);
ivec2 workgroupLoc = ivec2(gl_WorkGroupID.xy * WORKGROUP_SIZE) + globalOffset;

ivec2 globalVLocation = ivec2(workgroupLoc.x + int(gl_LocalInvocationID.x), workgroupLoc.y);
ivec2 globalStartVLocation = clamp(globalVLocation, ivec2(0, 0), BOARD_SIZE);
ivec2 localStartVLocation = globalStartVLocation - workgroupLoc;
uint localHeight = min(globalVLocation.y + WORKGROUP_SIZE, HEIGHT) - globalStartVLocation.y;

ivec2 globalHLocation = ivec2(workgroupLoc.x, workgroupLoc.y + int(gl_LocalInvocationID.x));
ivec2 globalStartHLocation = clamp(globalHLocation, ivec2(0, 0), BOARD_SIZE);
ivec2 localStartHLocation = globalStartHLocation - workgroupLoc;
uint localWidth = min(globalHLocation.x + WORKGROUP_SIZE, WIDTH) - globalStartHLocation.x;

shared Cell board[WORKGROUP_SIZE][WORKGROUP_SIZE];
shared bool friction[WORKGROUP_SIZE][WORKGROUP_SIZE];

void loadBoard();
void saveBoard();

void fall();
bool isCourseInsideBoard(const bool vertical);
void swapCells(const ivec2 location1, const ivec2 location2);
void initCourse(const bool vertical);
bool courseHasNext();
ivec2 courseNext();

void main()
{
    loadBoard();

    barrier();
    memoryBarrierShared();

    fall();

    barrier();
    memoryBarrierShared();

    saveBoard();
}

void loadBoard()
{
    if(globalVLocation.x < 0 || globalVLocation.x >= WIDTH) return;

    for (int y = 0; y < localHeight; y++)
    {
        board[localStartVLocation.x][localStartVLocation.y + y] = unpackCell(board1.data[globalStartVLocation.x + (globalStartVLocation.y + y) * WIDTH]);
    }
}

void saveBoard()
{
    if(globalVLocation.x < 0 || globalVLocation.x >= WIDTH) return;

    for (int y = 0; y < localHeight; y++)
    {
        board2.data[globalStartVLocation.x + (globalStartVLocation.y + y) * WIDTH] = packCell(board[localStartVLocation.x][localStartVLocation.y + y]);
    }
}

void fall()
{
    if(!isCourseInsideBoard(true)) return;

    initCourse(true);

    bool discardMove = false;
    ivec2 location = courseNext();
    uint previousMaterialId = board[location.x][location.y].materialId;
    Material previousMaterial = configuration.materials[previousMaterialId];
    ivec2 previousLocation = location;
    ivec2 topLocation = location;

    while(courseHasNext())
    {
        location = courseNext();
        uint materialId = board[location.x][location.y].materialId;
        
        if(materialId != previousMaterialId)
        {
            const Material material = configuration.materials[materialId];
            bool isStatic = previousMaterial.isStatic != 0 || material.isStatic != 0;

            if(!isStatic && !discardMove && previousMaterial.density > material.density)
            {
                bool solidToGaz = previousMaterial.type == SOLID && material.type == GAZ;
                if(solidToGaz)
                {
                    swapCells(topLocation, location);
                }
                else
                {
                    swapCells(previousLocation, location);
                }
                materialId = previousMaterialId;
                discardMove = true;
            }
            else
            {
                discardMove = false;
            }
            
            topLocation = location;
            previousMaterialId = materialId;
            previousMaterial = material;
        }

        previousLocation = location;
    }
}

void swapCells(const ivec2 location1, const ivec2 location2)
{
    Cell tmp = board[location1.x][location1.y];
    board[location1.x][location1.y] = board[location2.x][location2.y];
    board[location2.x][location2.y] = tmp;
}

bool courseVertical;
int courseOffset;
int courseSize;

bool isCourseInsideBoard(const bool vertical)
{
    if(vertical) return globalVLocation.x >= 0 && globalVLocation.x < WIDTH;
    else return globalHLocation.y >= 0 && globalHLocation.y < HEIGHT;
}

void initCourse(const bool vertical)
{
    courseVertical = vertical;
    courseOffset = -1;
    courseSize = int(vertical ? localHeight : localWidth);
}

bool courseHasNext()
{
    return courseOffset < courseSize - 1;
}

ivec2 courseNext()
{
    courseOffset++;
    return courseVertical ? ivec2(localStartVLocation.x, localStartVLocation.y + courseOffset) : ivec2(localStartHLocation.x + courseOffset, localStartHLocation.y);
}
