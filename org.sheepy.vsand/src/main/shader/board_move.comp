#version 450

#define WORKGROUP_SIZE 32

#include "util/rand_utils.glsl"
#include "util/material.glsl"
#include "util/crop.glsl"
#include "util/board.glsl"
#include "util/board_shared.glsl"

layout (local_size_x = WORKGROUP_SIZE, local_size_y = 1, local_size_z = 1) in;

void fall();
void swapCells(const ivec2 location1, const ivec2 location2);

void main()
{
    loadBoard();

    barrier();
    memoryBarrierShared();

    fall();

    barrier();
    memoryBarrierShared();

    saveBoard();
}

void fall()
{
    if(!course_init(true)) return;

    bool discardMove = false;
    uint materialId;
    uint previousMaterialId = board[course_location.x][course_location.y].materialId;
    Material previousMaterial = configuration.materials[previousMaterialId];
    ivec2 topLocation = course_location;
    uint count = 1;

    while(course_next())
    {
        materialId = board[course_location.x][course_location.y].materialId;
        if(materialId != previousMaterialId)
        {
            const Material material = configuration.materials[materialId];
            const bool isStatic = previousMaterial.isStatic != 0 || material.isStatic != 0;

            if(!isStatic && !discardMove && previousMaterial.density > material.density)
            {
                bool solidToGaz = previousMaterial.type == SOLID && material.type == GAZ;
                if(solidToGaz)
                {
                    swapCells(topLocation, course_location);
                }
                else
                {
                    swapCells(course_previousLocation, course_location);
                }
                materialId = previousMaterialId;
                discardMove = true;
            }
            else
            {
                discardMove = false;
            }
            
            topLocation = course_location;
            previousMaterialId = materialId;
            previousMaterial = material;
            count = 0;
        }

        count++;

        if(count >= 2)
        {
            board[course_location.x][course_location.y].pressed = true;
        }
    }
}

void swapCells(const ivec2 location1, const ivec2 location2)
{
    Cell tmp = board[location1.x][location1.y];
    board[location1.x][location1.y] = board[location2.x][location2.y];
    board[location2.x][location2.y] = tmp;
}
