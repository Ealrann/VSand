#version 450

#define CHUNK_WIDTH 78
#define CHUNK_HEIGHT 44

#define WORKGROUP_SIZE 8
#define DEFAULT_PRESSURE 1.

#define SQUARE		0
#define CIRCLE		1
#define LINE		2

#include "util/material.glsl"

const uint MOVE_TAG = 1u << 8;

layout (constant_id = 0) const int MATERIAL_COUNT = 1;
layout (constant_id = 1) const int WIDTH = 1;
layout (constant_id = 2) const int HEIGHT = 1;

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

// The definition of materials.
layout(binding = 0) uniform SConfiguration
{
    Material materials[MATERIAL_COUNT];
} configuration;

// The chunk state board.
layout(binding = 1) buffer SChunks
{
	int data[CHUNK_WIDTH][CHUNK_HEIGHT];
}chunks;

// The game board, with all the values.
layout(binding = 2) buffer SBoard
{
	uint data[WIDTH * HEIGHT];
}board;

layout (push_constant) uniform PushConstants
{
	// Shape to draw
	int shape;
	int size;
	int x;
	int y;

	// BoundingBox
	int minX;
	int minY;
	int maxX;
	int maxY;

	// For line, Rectangle to draw
	int x1;
	int y1;
	int x2;
	int y2;
	int x3;
	int y3;
	int x4;
	int y4;

	uint value;

}attributes;

bool testCircle(int x, int y);
bool testLine(int x, int y);
int computeSide(int x, int y, int x1, int y1, int x2, int y2);

void main()
{
	if (gl_GlobalInvocationID.x < WIDTH && gl_GlobalInvocationID.y < HEIGHT)
	{
		int x = int(gl_GlobalInvocationID.x);
		int y = int(gl_GlobalInvocationID.y);

		if (x >= attributes.minX && y >= attributes.minY && x <= attributes.maxX
				&& y <= attributes.maxY)
		{
			bool isInShape = false;
			switch (attributes.shape)
			{
			case SQUARE:
				isInShape = true;
				break;
			case CIRCLE:
				isInShape = testCircle(x, y);
				break;
			case LINE:
				isInShape = testLine(x, y) || testCircle(x, y);
				break;
			}

			if (isInShape)
			{
                uint value = board.data[x + y * WIDTH];
                uint currentMaterial = value & 0xFFu;
                uint targetMaterial = attributes.value & 0xFFu;

                if(currentMaterial != targetMaterial)
                {
                    uint packedMass = packHalf2x16(vec2(0., configuration.materials[targetMaterial].density));
                    board.data[x + (y * WIDTH)] = targetMaterial | (packedMass & 0xFFFF0000u) | MOVE_TAG;
                }
				chunks.data[gl_WorkGroupID.x][gl_WorkGroupID.y] = 3;
			}
		}
	}
}

bool testCircle(int x, int y)
{
	int distX = (attributes.x - x) * (attributes.x - x);
	int distY = (attributes.y - y) * (attributes.y - y);

	int halfSize = attributes.size >> 1; // divide by 2;

	return (distX + distY) <= (halfSize * halfSize);
}

bool testLine(int x, int y)
{
	// Algo from https://stackoverflow.com/a/2752753/4030058
	int x1 = attributes.x1;
	int y1 = attributes.y1;
	int x2 = attributes.x2;
	int y2 = attributes.y2;
	int x3 = attributes.x3;
	int y3 = attributes.y3;
	int x4 = attributes.x4;
	int y4 = attributes.y4;

	if (computeSide(x, y, x1, y1, x2, y2) < 0 || computeSide(x, y, x2, y2, x3, y3) < 0
	 || computeSide(x, y, x3, y3, x4, y4) < 0 || computeSide(x, y, x4, y4, x1, y1) < 0)
		return false;

	return true;
}

int computeSide(int x, int y, int x1, int y1, int x2, int y2)
{
	int A = -(y2 - y1);
	int B = x2 - x1;
	int C = -(A * x1 + B * y1);

	return A * x + B * y + C;
}
