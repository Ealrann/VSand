#version 450

#define CHUNK_WIDTH 78
#define CHUNK_HEIGHT 44

#define WORKGROUP_SIZE 8


#define FLAG_FORCE_CLEAR            1
#define FLAG_SHOW_SLEEPING_CHUNKS   2
#define FLAG_SHOW_PRESSURE          4

layout (constant_id = 0) const int MATERIAL_COUNT = 2;
layout (constant_id = 1) const int WIDTH = 1;
layout (constant_id = 2) const int HEIGHT = 1;

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	int padding;
	vec4 color;
};

// Random number, change each frame.
layout (push_constant) uniform PushConstants {
	int flags;
    int padding;
	int drawMaterialId;
	int drawRadius;
	ivec2 mousePos;
} pushConstants;

layout(rgba8, binding = 0) uniform image2D outImage;

layout(binding = 1) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

// The chunk state board.
layout(binding = 2) buffer SChunks
{
	int data[CHUNK_WIDTH][CHUNK_HEIGHT];
}chunks;

layout(binding = 3) buffer readonly SBoard
{
	uint data[WIDTH * HEIGHT];
}board;

const uint G_MASK = 255 << 8;
const uint B_MASK = 255;
const vec4 DEBUG_COLOR = vec4(1.0, 0.5, 0.5, 0.0);

shared bool colorTweakPreTest;
shared bool sleeping;

bool testSquare(ivec2 upLeftCorner1, ivec2 downRightCorner1, ivec2 upLeftCorner2, ivec2 downRightCorner2);
bool testCircle(ivec2 loc, ivec2 circleLoc, int radius);
vec4 computeColor(ivec2 loc);

void main()
{
    if (gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
    {
        return;
    }

	if(gl_LocalInvocationIndex == 0)
	{
//		int chunkState = chunks.data[gl_WorkGroupID.x][gl_WorkGroupID.y];
//
		ivec2 workgroupUpLeftCorner    = ivec2(gl_WorkGroupID.xy)     * WORKGROUP_SIZE;
		ivec2 workgroupDownRightCorner = ivec2(gl_WorkGroupID.xy + 1) * WORKGROUP_SIZE - 1;
		ivec2 cercleUpLeftCorner    = pushConstants.mousePos - pushConstants.drawRadius;
		ivec2 cercleDownRightCorner = pushConstants.mousePos + pushConstants.drawRadius;

		colorTweakPreTest = testSquare(workgroupUpLeftCorner,
										workgroupDownRightCorner,
										cercleUpLeftCorner,
										cercleDownRightCorner);
//
//		if((chunkState & 2) != 0)
//		{
			sleeping = false;
//			if(colorTweakPreTest == false)
//			{
//				chunks.data[gl_WorkGroupID.x][gl_WorkGroupID.y] = chunkState ^ 2;
//			}
//		}
//		else
//		{
//			sleeping = true;
//		}
	}


	barrier();

	if(gl_LocalInvocationIndex == 0 && colorTweakPreTest == true)
	{
		chunks.data[gl_WorkGroupID.x][gl_WorkGroupID.y] |= 2;
	}

	ivec2 loc = ivec2(gl_GlobalInvocationID.xy);

	if(  loc.x >= WIDTH
		|| loc.y >= HEIGHT
		|| (   pushConstants.flags == 0
			&& colorTweakPreTest == false
			&& sleeping == true))
	{
		return;
	}

	vec4 finalColor = computeColor(loc);

	imageStore(outImage, loc, finalColor);
}

vec4 computeColor(ivec2 loc)
{
	bool colorTweak = false;
	vec4 addColor = vec4(0, 0, 0, 0);
    uint value = board.data[loc.x + loc.y * WIDTH];
    uint materialId = value & 0xFFu;
    vec4 color = configuration.materials[materialId].color;


	if(colorTweakPreTest && testCircle(loc, pushConstants.mousePos, pushConstants.drawRadius))
	{
		Entry material = configuration.materials[pushConstants.drawMaterialId];
        addColor += vec4(material.color.xyz + 0.2, 0);

		colorTweak = true;
	}

	if(sleeping == true	&& (pushConstants.flags & FLAG_SHOW_SLEEPING_CHUNKS) != 0)
	{
		addColor += vec4(1, 0.5, 0.5, 0);
		colorTweak = true;
	}

    if((pushConstants.flags & FLAG_SHOW_PRESSURE) != 0)
    {
        bool moving = (value & (1u << 8)) != 0;
        if(moving)
        {
            addColor = vec4(0., 0., 0.8, 0);
        }
        else
        {
            float pressure = unpackHalf2x16(value).y - 1.;
            if (pressure >= 0.)
            {
                addColor += vec4(clamp(pressure, 0., 1.), 0, 0, 0);
            }
            else
            {
                addColor += vec4(0, clamp(-pressure, 0., 1.), 0, 0);
            }
        }
        return clamp(color/4. + addColor, 0., 1.);
    }

	if(colorTweak)
	{
		return clamp(color + (addColor / 2.), 0., 1.);
	}
	else
	{
		return color;
	}
}


bool testSquare(ivec2 upLeftCorner1, ivec2 downRightCorner1, ivec2 upLeftCorner2, ivec2 downRightCorner2)
{
   return !((downRightCorner1.x < upLeftCorner2.x)
			|| (downRightCorner1.y < upLeftCorner2.y)
			|| (downRightCorner2.x < upLeftCorner1.x)
			|| (downRightCorner2.y < upLeftCorner1.y));
}

bool testCircle(ivec2 loc, ivec2 circleLoc, int radius)
{
	ivec2 dist = (circleLoc - loc) * (circleLoc - loc);
	return (dist.x + dist.y) <= (radius * radius);
}
