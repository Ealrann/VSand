#version 450

#define CHUNK_WIDTH 78
#define CHUNK_HEIGHT 44

#define WORKGROUP_SIZE 16

#include "util/rand_utils.glsl"
#include "util/material.glsl"
#include "util/crop.glsl"
#include "util/board.glsl"

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

const uint STATIC_TRANSFO_FLAG = 1 << 30;

bool transformation(ivec2 loc);

void main()
{
    if (gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
    {
        return;
    }

    ivec2 loc = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);


    transformation(loc);
}


void transformPropagate(ivec2 loc, uint currentValue, uint targetValue, uint propagation);

bool transformation(ivec2 loc)
{
    bool res = false;
    uint val = board2.data[loc.x + loc.y * WIDTH];
    uint currentValue = val & 0xFFu;
    bool moved = (val & FALLING_FLAG) != 0;

    // UP, DOWN, RIGHT, LEFT
    uvec4 neighborValue = uvec4(loc.y > 0 ? board2.data[loc.x + (loc.y - 1) * WIDTH] : 0,
                                loc.y < HEIGHT - 1 ? board2.data[loc.x + (loc.y + 1) * WIDTH] : 0,
                                loc.x < WIDTH - 1 ?   board2.data[loc.x + 1 + loc.y * WIDTH] : 0,
                                loc.x > 0 ? board2.data[loc.x - 1 + loc.y * WIDTH] : 0)
                                    & 0xFFu;
    bvec4 differentValue = notEqual(neighborValue, uvec4(currentValue));

    if(any(differentValue))
    {
        uvec4 transfoIndex = neighborValue * MATERIAL_COUNT + currentValue;
        uvec4 transfoIndexX = transfoIndex >> 2;
        uvec4 transfoIndexY = transfoIndex & 3u;
        uint rand = -1;
        uint transfoToApply = -1;

        for(int i = 0; i < 4; i++)
        {
            uint transfo = transformations.data[transfoIndexX[i]][transfoIndexY[i]];
            bool staticTransfo = (transfo & STATIC_TRANSFO_FLAG) != 0;
            if(transfo != -1 && (differentValue[i] || (staticTransfo && !moved)))
            {
                if(rand == -1)
                {
                    float genRand = sqrt(random(vec4(loc, pushConstants.random, 3)));
                    rand = uint(round(genRand * 1000.));
                }

                uint probability = (transfo << 2) >> 18;
                if (rand < probability)
                {
                    transfoToApply = transfo;
                    break;
                }
            }
        }

        if(transfoToApply != -1)
        {
            uint targetValue = transfoToApply & 255u;
            board2.data[loc.x + loc.y * WIDTH] &= 0xFFFFFF00u;
            board2.data[loc.x + loc.y * WIDTH] |= targetValue;
            uint propagation = (transfoToApply & 65280u) >> 8;
            if(propagation > 1)
            {
                transformPropagate(loc, currentValue, targetValue, propagation);
            }
            res = true;
        }
    }

    return res;
}

void transformPropagate(ivec2 loc, uint currentValue, uint targetValue, uint propagation)
{
    int offset = 1;
    bool up = true;
    bool down = true;
    bool right = true;
    bool left = true;

    while(propagation > 1)
    {
        if (up && loc.y - offset >= 0)
        {
            uint valueUp = board2.data[loc.x + (loc.y - offset) * WIDTH] & 0xFFu;
            if (valueUp == currentValue)
            {
                board2.data[loc.x + (loc.y - offset) * WIDTH] &= 0xFFFFFF00u;
                board2.data[loc.x + (loc.y - offset) * WIDTH] |= targetValue;
            }
            else
            {
                up = false;
            }
        }
        if (down && loc.y + offset < HEIGHT)
        {
            uint valueDown = board2.data[loc.x + (loc.y + offset) * WIDTH] & 0xFFu;
            if (valueDown == currentValue)
            {
                board2.data[loc.x + (loc.y + offset) * WIDTH] &= 0xFFFFFF00u;
                board2.data[loc.x + (loc.y + offset) * WIDTH] |= targetValue;
            }
            else
            {
                down = false;
            }
        }
        if (right && loc.x + offset < WIDTH)
        {
            uint valueRight = board2.data[loc.x + offset + loc.y * WIDTH] & 0xFFu;
            if (valueRight == currentValue)
            {
                board2.data[loc.x + offset + loc.y * WIDTH] &= 0xFFFFFF00u;
                board2.data[loc.x + offset + loc.y * WIDTH] |= targetValue;
            }
            else
            {
                right = false;
            }
        }
        if (left && loc.x - offset >= 0)
        {
            uint valueLeft = board2.data[loc.x - offset + loc.y * WIDTH] & 0xFFu;
            if (valueLeft == currentValue)
            {
                board2.data[loc.x - offset + loc.y * WIDTH] &= 0xFFFFFF00u;
                board2.data[loc.x - offset + loc.y * WIDTH] |= targetValue;
            }
            else
            {
                left = false;
            }
        }

        propagation --;
        offset ++;
    }
}
