#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1024
#define HEIGHT 576
//#define WIDTH 2048
//#define HEIGHT 1152
#define WORKGROUP_SIZE 32

layout (local_size_x = 1, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	float viscosity;
	float r;
	float g;
	float b;

	// Padding for the alignement
	float padding1;
};

layout(binding = 0) uniform SConfiguration
{
	Entry materials[16];
}configuration;

layout(binding = 1) buffer buf2
{
	int data[WIDTH][HEIGHT];
}board;

bool check(int x, int y, int runoff, int dir, int srcDensity);

void main()
{
	int y = int(gl_GlobalInvocationID.y);
	int value0;
	int value1;
	int value2;
	int sourceDensity;
	int underDensity;

	for (int x = 0; x < WIDTH; x++)
	{
		value0 = x > 0 ? board.data[x - 1][y] : 0;
		value1 = board.data[x][y];
		value2 = x < (WIDTH - 1) ? board.data[x + 1][y] : 0;
		sourceDensity = configuration.materials[value1].density;

		underDensity = 0;

		if (y < (HEIGHT - 1))
		{
			int valueUnder = board.data[x][y + 1];
			underDensity = configuration.materials[valueUnder].density;
		}

		if (configuration.materials[value1].isStatic == 0)
		{
			bool freeLeft = configuration.materials[value0].isStatic == 0
					&& configuration.materials[value0].density < sourceDensity;
			bool freeRight = configuration.materials[value2].isStatic == 0
					&& configuration.materials[value2].density < sourceDensity;

			freeLeft = freeLeft
					&& check(x - 1, y + 1,
							configuration.materials[value1].runoff, -1,
							sourceDensity);

			freeRight = freeRight
					&& check(x + 1, y + 1,
							configuration.materials[value1].runoff, 1,
							sourceDensity);


			bool fallDown = sourceDensity > underDensity;
			if ((freeRight || freeLeft)
					&& (!fallDown || !freeRight || !freeLeft))
			{
				// Choose only one
				if (freeLeft && freeRight)
				{
					if (mod(y, 2) == 0)
					{
						freeLeft = false;
					}
					else
					{
						freeRight = false;
					}
				}

				if (freeLeft)
				{
					board.data[x][y] = value0;
					if (x > 0)
					{
						board.data[x - 1][y] = value1;
					}
					// Don't try to do again the left one
					x += 1;
				}
				else if (freeRight)
				{
					board.data[x][y] = value2;
					if (x < WIDTH - 1)
					{
						board.data[x + 1][y] = value1;
					}
					// Don't try to do again the right one
					x += 2;
				}
			}
		}
	}
}

bool check(int x, int y, int runoff, int dir, int srcDensity)
{
	while (runoff != 0)
	{
		if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT)
		{
			int valueAbove = board.data[x][y - 1];
			if (configuration.materials[valueAbove].isStatic == 1
					|| configuration.materials[valueAbove].density > srcDensity)
			{
				// stuck
				return false;
			}

			int value = board.data[x][y];
			if (configuration.materials[value].isStatic == 0
					&& configuration.materials[value].density < srcDensity)
			{
				return true;
			}
		}
		else
		{
			return true;
		}
		x += dir;
		runoff--;
	}

	return false;
}
