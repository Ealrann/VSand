#version 450

#define WIDTH 1024
#define HEIGHT 512
//#define WIDTH 2048
//#define HEIGHT 1152
#define WORKGROUP_SIZE 128

layout (local_size_x = 1, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	float viscosity;
	float r;
	float g;
	float b;

	// Padding for the alignement
	float padding1;
};

layout(binding = 0) uniform SConfiguration
{
	Entry materials[16];
}configuration;

layout(binding = 1) buffer buf2
{
	int data[WIDTH][HEIGHT];
}board;

bool check(int x, int y, int runoff, int dir, int srcDensity);

void main()
{
	int y = int(gl_GlobalInvocationID.y);

	int prevValue = 0;
	int prevIndex = -1;
	bool freeLeft = false;
	bool freeRight;
	bool fallDown;
	int length;
	int locationToSwap;

	for (int x = 0; x < WIDTH + 1; x++)
	{
		int currentValue = x < WIDTH ? board.data[x][y] : 0;

		if (currentValue != prevValue)
		{
			if (configuration.materials[currentValue].isStatic == 0
					&& configuration.materials[prevValue].isStatic == 0)
			{
				int currentDensity = configuration.materials[currentValue].density;

				// if need of Swap to Left
				if (currentDensity > configuration.materials[prevValue].density)
				{
					int underDensity = 0;
					if (y < (HEIGHT - 1))
					{
						underDensity = configuration.materials[board.data[x][y + 1]].density;
					}

					// We need to remeber the last location of the previous material
					prevIndex = x - 1;

					freeLeft = check(x - 1, y + 1, configuration.materials[currentValue].runoff, -1,
							currentDensity);

					// We will iterate the full line of this new Material to know its length
					int nextValue = 0;
					while ((x + 1) <= WIDTH - 1)
					{
						nextValue = (x + 1) < WIDTH ? board.data[x + 1][y] : 0;
						if (nextValue != currentValue)
						{
							break;
						}
						x++;
					}

					length = x - prevIndex;
					fallDown = currentDensity > underDensity;
					if (freeLeft && (!fallDown || length > 1))
					{
						// if freeLeft, we have something to do.
						locationToSwap = prevIndex + 1;
						if (length >= configuration.materials[currentValue].runoff * 2)
						{
							locationToSwap = prevIndex
									+ configuration.materials[currentValue].runoff;
						}
						else
						{
							locationToSwap = int(prevIndex + ceil(length / 2.0));
						}

						// SWAP LEFT
						if (prevIndex >= 0)
							board.data[prevIndex][y] = currentValue;
						if (locationToSwap < WIDTH)
							board.data[locationToSwap][y] = prevValue;

						prevValue =
								(locationToSwap + 1 < WIDTH) ?
										board.data[locationToSwap + 1][y] : 0;
						prevIndex = locationToSwap + 1;
						x++;
						continue;
					}
				}
				// if need of Swap to Right
				else if (currentDensity < configuration.materials[prevValue].density)
				{
					Entry prevMaterial = configuration.materials[board.data[x - 1][y]];
					int prevDensity = prevMaterial.density;
					int underDensity = 0;
					if (y < (HEIGHT - 1))
					{
						underDensity = configuration.materials[board.data[x - 1][y + 1]].density;
					}

					freeRight = check(x, y + 1, prevMaterial.runoff, 1, prevDensity);

					length = x - prevIndex;
					fallDown = prevDensity > underDensity;
					if (freeRight && (!fallDown || length > 1))
					{
						locationToSwap = prevIndex;
						if (length > prevMaterial.runoff)
						{
							length = prevMaterial.runoff;
							locationToSwap = x - length;
						}

						// SWAP RIGHT
						if (locationToSwap >= 0)
							board.data[locationToSwap][y] = currentValue;
						if (x < WIDTH)
							board.data[x][y] = prevValue;

						prevValue = (x + 1 < WIDTH) ? board.data[x + 1][y] : 0;
						prevIndex = x + 1;
						x ++;
						continue;
					}
				}
			}
			prevValue = currentValue;
			prevIndex = x;
		}
	}
}

bool check(int x, int y, int runoff, int dir, int srcDensity)
{
	while (runoff != 0)
	{
		if (x >= 0 && x < WIDTH && y >= 0 && y < HEIGHT)
		{
			int valueAbove = board.data[x][y - 1];
			if (configuration.materials[valueAbove].isStatic == 1
					|| configuration.materials[valueAbove].density > srcDensity)
			{
				// stuck
				return false;
			}

			int value = board.data[x][y];
			if (configuration.materials[value].isStatic == 0
					&& configuration.materials[value].density < srcDensity)
			{
				return true;
			}
		}
		else
		{
			return true;
		}
		x += dir;
		runoff--;
	}

	return false;
}
