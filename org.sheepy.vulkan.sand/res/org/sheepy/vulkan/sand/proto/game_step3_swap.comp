#version 450

#define WIDTH 1024
#define HEIGHT 512
//#define WIDTH 2048
//#define HEIGHT 1152
#define WORKGROUP_SIZE 32

#define UP    0
#define DOWN  1
#define RIGHT 2
#define LEFT  3

#define TO_UP    1 << 0
#define TO_DOWN  1 << 1
#define TO_RIGHT 1 << 2
#define TO_LEFT  1 << 3

#define FROM_UP    1 << 4
#define FROM_DOWN  1 << 5
#define FROM_RIGHT 1 << 6
#define FROM_LEFT  1 << 7

#define RANDOM_1_LOC  8
#define RANDOM_2_LOC  10
#define RANDOM_3_LOC  12
#define RANDOM_4_LOC  14

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Entry {
	int isStatic;
	int density;
	int runoff;
	float viscosity;
	float r;
	float g;
	float b;

	// Padding for the alignement
	float padding1;
};

layout(binding = 0) uniform SConfiguration
{
	Entry materials[16];
}configuration;

layout(binding = 1) buffer SBoard
{
	int data[WIDTH][HEIGHT];
}board;

layout(binding = 2) readonly buffer SDecision
{
	uint data[WIDTH][HEIGHT];
}decision;

/**
 * Here, we will apply the swap
 */
void main() {

	if(gl_GlobalInvocationID.x >= WIDTH || gl_GlobalInvocationID.y >= HEIGHT)
		return;

	int x = int(gl_GlobalInvocationID.x);
	int y = int(gl_GlobalInvocationID.y);
	int value = board.data[x][y];

	// We will take the value of our target neighbor if he do the same move.
	uint dir = decision.data[x][y] & 15;

	if (dir != 0) {
		// resolve the direction
		uint invertDir = 0;
		int targetX = x;
		int targetY = y;
		if (dir == TO_RIGHT) {
			targetX += 1;
			invertDir = TO_LEFT;
		} else if (dir == TO_LEFT) {
			targetX -= 1;
			invertDir = TO_RIGHT;
		} else if (dir == TO_UP) {
			targetY -= 1;
			invertDir = TO_DOWN;
		} else {
			targetY += 1;
			invertDir = TO_UP;
		}

		if (targetX < 0 || targetX >= WIDTH || targetY < 0 || targetY >= HEIGHT
				|| (decision.data[targetX][targetY] & invertDir) != 0) {
			board.data[x][y] = int(
					(decision.data[targetX][targetY] & (65535 << 16)) >> 16);
		}
	}
}
