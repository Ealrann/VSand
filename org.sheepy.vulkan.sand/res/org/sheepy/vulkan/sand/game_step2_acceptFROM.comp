#version 450

#define WIDTH 1024
#define HEIGHT 512
//#define WIDTH 2048
//#define HEIGHT 1152
#define WORKGROUP_SIZE 32

#define UP    0
#define DOWN  1
#define RIGHT 2
#define LEFT  3

#define TO_UP    1 << 0
#define TO_DOWN  1 << 1
#define TO_RIGHT 1 << 2
#define TO_LEFT  1 << 3

#define RANDOM_1_LOC  8
#define RANDOM_2_LOC  10
#define RANDOM_3_LOC  12
#define RANDOM_4_LOC  14

layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	float viscosity;
	float r;
	float g;
	float b;

	// Padding for the alignement
	float padding1;
};

layout(binding = 0) uniform SConfiguration
{
	Entry materials[16];
}configuration;

layout(binding = 1) uniform FrameUniformBuffer
{
	uint random;
}FUB;

layout(binding = 2) readonly buffer SBoard
{
	int data[WIDTH][HEIGHT];
}board;

layout(binding = 3) buffer SDecision
{
	uint data[WIDTH][HEIGHT];
}decision;

/**
 * For the pixels that have no preferences, if a neighbor want to come here, we accept the move.
 */
void main()
{
	int x = int(gl_GlobalInvocationID.x);
	int y = int(gl_GlobalInvocationID.y);
	int value = board.data[x][y];

	if (configuration.materials[value].isStatic == 0)
	{
		int density = configuration.materials[value].density;
		int rLocation = RANDOM_1_LOC;

		uint decisionValue = decision.data[x][y];

		for (int i = 0; i < 4; i++)
		{
			uint iDir = (decisionValue & (3 << rLocation)) >> rLocation;
			// iDir should be between 0 and 3 (included) here

			// The down is impossible here:
			// We cannot be the target of a heavier down object.
			if (iDir != DOWN)
			{
				// resolve the direction
				uint invertDir = 0;
				int targetX = x;
				int targetY = y;
				switch (iDir)
				{
				case RIGHT:
					targetX += 1;
					invertDir = TO_LEFT;
					break;
				case LEFT:
					targetX -= 1;
					invertDir = TO_RIGHT;
					break;
				case UP:
					targetY -= 1;
					invertDir = TO_DOWN;
					break;
				}

				if (targetX >= 0 && targetX < WIDTH && targetY >= 0 && targetY < HEIGHT)
				{
					int targetValue = board.data[targetX][targetY];
					int targetDensity = configuration.materials[targetValue].density;

					if (targetDensity > density
							&& (decision.data[targetX][targetY] & invertDir) != 0)
					{
						// convert iDir to a mask
						uint maskDir = 1 << iDir;

						decision.data[x][y] = ((decisionValue >> 8) << 8) | maskDir
								| (targetValue << 16);

						break;
					}
				}
			}

			rLocation += 2;
		}
	}
}
