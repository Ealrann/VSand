#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WIDTH 1280
#define HEIGHT 720

#define CHUNK_WIDTH 40
#define CHUNK_HEIGHT 23

#define WORKGROUP_SIZE_X 32
#define WORKGROUP_SIZE_Y 32

#define MATERIAL_COUNT 32

precision lowp float;

layout (local_size_x = WORKGROUP_SIZE_X, local_size_y = WORKGROUP_SIZE_Y, local_size_z = 1) in;

struct Entry
{
	int isStatic;
	int density;
	int runoff;
	uint rgb;
};

layout(binding = 0) uniform SConfiguration
{
	Entry materials[MATERIAL_COUNT];
}configuration;

layout(binding = 1) readonly buffer SBoard
{
	int data[WIDTH][HEIGHT];
	int chunks[CHUNK_WIDTH][CHUNK_HEIGHT];
}board;

layout(rgba8, binding = 2) uniform image2D outImage;

const uint G_MASK = 255 << 8;
const uint B_MASK = 255;

void main()
{
	if (gl_GlobalInvocationID.y >= HEIGHT)
		return;

	if((board.chunks[gl_WorkGroupID.x][gl_WorkGroupID.y] & 4) == 0)
	{
		// imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(1.0, 0.5, 0.5, 0.1));
		return;
	}

	Entry material =
			configuration.materials[board.data[gl_GlobalInvocationID.x][gl_GlobalInvocationID.y]];

	float r = (material.rgb >> 16) / 255.;
	float g = ((material.rgb & G_MASK) >> 8) / 255.;
	float b = (material.rgb & B_MASK) / 255.;

	imageStore(outImage, ivec2(gl_GlobalInvocationID.xy), vec4(r, g, b, 1.0));
}
